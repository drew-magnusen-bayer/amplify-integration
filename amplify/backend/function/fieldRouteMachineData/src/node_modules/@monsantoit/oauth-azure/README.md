# OAuth utilities

### httpGetToken

Gets an azure oauth token via client credentials as a promise, caching that
token until 90 seconds before its expiry.

## httpGetToken

options:
- clientId
- clientSecret
- url
- scope (defaults to $CLIENT_ID/.default)

``` javascript
import oauth from '@monsantoit/oauth-azure'
import {clientId, clientSecret, url} from './azureSettings'

// create an instance of the token generator, for a given clientId.
const getToken = oauth.httpGetToken({clientId, clientSecret, url}) // returns a function.

// invoke the instance as you see fit.
export function getAuthorizationHeader() {
    // if nothing is passed into the getToken invocation,
    // it presumes a promise.
    return getToken().then((token) => {Authorization: `Bearer ${token}`})
}
```

### Usage with callback:

``` javascript
import oauth from '@monsantoit/oauth-azure'
import {clientId, clientSecret, url} from './azureSettings'

// create an instance of the token generator, for a given clientId.
const getToken = oauth.httpGetToken({clientId, clientSecret, url}) // returns a function.

// invoke the instance as you see fit.
export function getAuthorizationHeader(callback) {
    // by passing a callback into getToken, it will return your
    // invoked callback
    return getToken((err, token) => {
        if (err) {
            return callback(err);
        } else {
            return callback(null, {Authorization: `Bearer ${token}`});
        }
    });
}
```
### Autorefresh
Tokens should automatically refresh within 90 seconds of expiration. If there's a network or azure error, the request will retry three times, rescheduling the request every 30 seconds.

Autorefreshing also enables synchronous access from a token cache, rather than a promise. See the cache section below for details.

#### Disabling Refresh

If you don't want or need automatic refresh, you can disable it by pasing `autoRefresh: false` as part of the initial configuration. The token will still refresh, but will wait until a token is explictly requested before fetching a fresh token.

``` javascript
import oauth from '@monsantoit/oauth-azure'

oauth.httpGetToken({
    clientId: "yourClient",
    clientSecret: "yourSecret",
    url: "azure-url",
    autoRefresh: false
})

```

If you need to remove autorefresh on `SIGTERM`, `SIGINT` or any other process signal, you can use a process listener to disable autorefresh.

``` javascript
import oauth from '@monsantoit/oauth-azure'

process.on('SIGTERM', () => { oauth.refresh.disable() })
```

### using your own logger
Any errors getting the token in the background are by default written to console.error.  If you want to provide your own logger, make sure it supports the *error* function.
``` javascript
import oauth from '@monsantoit/oauth-azure'
import express from 'express'
import routes from './routes'
import {clientId, clientSecret, url} from './azureSettings' // {clientId, clientSecret, url}
import winston from 'winston'

const consoleTransport = new winston.transports.Console({level: 'info', stderrLevels: ['error']})

const logger = winston.createLogger({transports: [consoleTransport]})

oauth.httpGetToken({clientId, clientSecret, url, logger})
```

### cache
A token store is available for synchronous fetching. Once the initial request has been kicked off, apps can grab the latest valid token through the cache module. This can be useful for integrating with third-party libraries without forcing everything into a promise chain.

``` javascript
import oauth from '@monsantoit/oauth-azure'
import express from 'express'
import routes from './routes'
import {clientId, clientSecret, url} from './azureSettings' // {clientId, clientSecret, url}

const app = express()
const app.use('/v1', routes)

// set up your environment. The token-fetching process needs to run at least once.
oauth.httpGetToken({clientId, clientSecret, url})
.then(() => express.listen() )
.catch(console.error)

// later, in another module...
import oauth, {cache} from '@monsantoit/oauth-azure'
import {clientId, clientSecret, url} from '../azureSettings'
import superagent from 'superagent'

const wrappedAgent = {}
const methods = ['get', 'put', 'post', 'patch', 'options', 'del', 'delete']

// built an instance of superagent that automatically adds the latest token.
const authAgent = methods.reduce((accumulation, method) => {
    accumulation[method] = (url) => {
        const token = cache.get({clientId, clientSecret, url})
        return superagent[method](url).set('Authorization', `Bearer ${token}`)
    }

    return accumulation
}, {})

module.exports = authAgent
```

### CHANGELOG

1.1.1 - made `cache.get(options)` use the same default scope as `httpTokenFetch(options)`