const vaultCF = require('@monsantoit/vault-cf-services')
const paramStore = require('../../../src/processors/aws/paramStore')
const authenticators = require('../../../src/processors/vault/authenticators')
const path = require('path')
const processors = require('../../../src/processors/index')
const fs = require('fs')

describe('processors', () => {
    const sandbox = sinon.createSandbox()
    const vault = {
        read: sandbox.stub()
    }

    beforeEach(() => {
        sandbox.stub(paramStore, 'getSSMParameters')

        vault.read.withArgs('secret/stuff').resolves({data: {a: 'A', b: 'B'}})
        vault.read.withArgs('secret/other').resolves({data: {c: 'C', d: 'D'}})
        vault.read.withArgs('secret/stuff/a').resolves({data: {direct: 'a'}})
        vault.read.withArgs('kv/data/foo').resolves({data: {data: {bar: 'baz'}}})
        vault.read.withArgs('secret/stuff/error/path').rejects(new Error('unauthorized'))

        paramStore.getSSMParameters
            .withArgs([
                'aws/param/store/value',
                'aws/param/store/other-value',
                'aws/param/store/final-value'
            ])
            .resolves({
                'aws/param/store/value': 'secrets',
                'aws/param/store/other-value': 'super secret',
                'aws/param/store/final-value': 'ultra secret'
            })

        sandbox.stub(authenticators, 'getAWSClient').resolves(vault)
        sandbox.stub(authenticators, 'getLocalTokenClient').resolves(vault)
        sandbox.stub(vaultCF, 'getVault').resolves(vault)
    })

    afterEach(() => {
        sandbox.restore()
    })

    describe('readVaultFromConfig', () => {
        const config = {
            app_role: 'AppRole',
            app_secret_id: 'secretId',
            testA: 'vault://secret/stuff/a'
        }

        it('returns a new config', async () => {
            const params = {
                enabled: true,
                url: {value: 'https://vault.agro.services'},
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                }
            }
            const data = await processors.readVaultFromConfig(params)(config)

            data.should.eql({
                app_role: 'AppRole',
                app_secret_id: 'secretId',
                testA: 'A'
            })
        })

        it('returns a new config using kv paths', async () => {
            const params = {
                enabled: true,
                url: {value: 'https://vault.agro.services'},
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                }
            }

            const data = await processors.readVaultFromConfig(params)({
                ...config,
                testKV: 'vault://kv/data/foo/bar'
            })

            data.should.eql({
                app_role: 'AppRole',
                app_secret_id: 'secretId',
                testA: 'A',
                testKV: 'baz'
            })
        })

        it('throws if any vault path cannot be read', async () => {
            const params = {
                enabled: true,
                url: 'https://vault.agro.services',
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                }
            }

            try {
                await processors.readVaultFromConfig(params)({
                    ...config,
                    testB: 'vault://secret/stuff/error/path',
                    testC: 'vault://secret/stuff/c'
                })
                should.fail()
            } catch (err) {
                err.message.should.include(
                    'The following vault paths were inaccessible, or contained no data: secret/stuff/error/path, secret/stuff/c'
                )
            }
        })

        it('throws if options fail to generate a vault client', async () => {
            vaultCF.getVault.restore()
            const params = {
                enabled: true,
                url: 'https://vault.agro.services',
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'missing_app_role'},
                    secretId: {inConfig: 'missing_app_secret_id'}
                }
            }

            try {
                await processors.readVaultFromConfig(params)(config)
                should.fail()
            } catch (err) {
                err.message.should.include('Missing credentials.role_id!')
            }
        })

        it('does nothing if enabled is false', async () => {
            vaultCF.getVault.restore()
            const params = {
                url: {value: 'https://vault.agro.services'},
                auth: {
                    type: 'approle',
                    roleId: {inConfig: 'missing_app_role'},
                    secretId: {inConfig: 'missing_app_secret_id'}
                },
                enabled: false
            }

            const data = await processors.readVaultFromConfig(params)(config)
            data.should.eql(config)
        })

        it('changes authentication methods based on auth.type', async () => {
            const baseOptions = {
                url: 'https://vault.agro.services',
                enabled: true,
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                }
            }

            const appRole = {
                ...baseOptions,
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                }
            }
            const awsRole = {
                ...baseOptions,
                auth: {
                    type: 'awsRole',
                    roleName: 'test'
                }
            }

            const local = {
                ...baseOptions,
                auth: {type: 'local'}
            }

            const auto = {
                ...baseOptions,
                auth: {
                    type: 'auto',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'},
                    roleName: 'test'
                }
            }

            await processors.readVaultFromConfig(appRole)({...config})
            vaultCF.getVault.callCount.should.eql(1)

            await processors.readVaultFromConfig(awsRole)({...config})
            authenticators.getAWSClient.callCount.should.eql(1)

            await processors.readVaultFromConfig(local)({...config})
            authenticators.getLocalTokenClient.callCount.should.eql(1)

            await processors.readVaultFromConfig(auto)({...config})
            vaultCF.getVault.callCount.should.eql(2)
            authenticators.getAWSClient.callCount.should.eql(2)
            authenticators.getLocalTokenClient.callCount.should.eql(2)
        })

        it('resolves auto-auth by returning the first successful client.', async () => {
            const params = {
                url: 'https://vault.agro.services',
                enabled: true,
                auth: {
                    type: 'auto',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'},
                    roleName: 'test'
                }
            }

            const localVaultClient = {
                read: sandbox
                    .stub()
                    .withArgs('secret/auto')
                    .resolves({data: {a: 'auto-secret'}})
            }
            const awsVaultClient = {
                read: sandbox
                    .stub()
                    .withArgs('secret/auto')
                    .resolves({data: {a: 'auto-secret'}})
            }
            const appRoleVaultClient = {
                read: sandbox
                    .stub()
                    .withArgs('secret/auto')
                    .resolves({data: {a: 'auto-secret'}})
            }

            const autoConfig = {
                ...config,
                testA: 'vault://secret/auto/a'
            }

            // only local works
            authenticators.getAWSClient.rejects()
            vaultCF.getVault.rejects()
            authenticators.getLocalTokenClient.resolves(localVaultClient)

            await processors.readVaultFromConfig(params)({...autoConfig})
            localVaultClient.read.callCount.should.eql(1)

            // only aws works
            authenticators.getAWSClient.resolves(awsVaultClient)
            authenticators.getLocalTokenClient.rejects()

            await processors.readVaultFromConfig(params)({...autoConfig})
            awsVaultClient.read.callCount.should.eql(1)

            // only approle works
            authenticators.getAWSClient.rejects()
            vaultCF.getVault.resolves(appRoleVaultClient)

            await processors.readVaultFromConfig(params)({...autoConfig})
            appRoleVaultClient.read.callCount.should.eql(1)
        })
    })
    describe('readParamStoreFromConfig', () => {
        const config = {
            testA: 'awsparam://aws/param/store/value',
            testB: 'awsparam://aws/param/store/other-value',
            testC: 'awsparam://aws/param/store/final-value',
            nonParam: 'something else'
        }

        it('returns a new config with awsparam values resolved', async () => {
            const data = await processors.readParamStoreFromConfig({enabled: true})(config)

            data.should.eql({
                testA: 'secrets',
                testB: 'super secret',
                testC: 'ultra secret',
                nonParam: 'something else'
            })
        })

        it('returns a new config with deeply configured awsparam values resolved', async () => {
            const deepConfig = {
                testA: {
                    deepA: {
                        valueA: 'awsparam://aws/param/store/value',
                        deepB: {
                            valueB: 'awsparam://aws/param/store/other-value',
                            deepC: {
                                valueC: 'awsparam://aws/param/store/final-value'
                            }
                        }
                    }
                }
            }

            const data = await processors.readParamStoreFromConfig({enabled: true})(deepConfig)

            data.should.eql({
                testA: {
                    deepA: {
                        valueA: 'secrets',
                        deepB: {
                            valueB: 'super secret',
                            deepC: {
                                valueC: 'ultra secret'
                            }
                        }
                    }
                }
            })
        })

        it('does nothing if enabled is false', async () => {
            const data = await processors.readParamStoreFromConfig({enabled: false})(config)
            data.should.eql(config)
        })
    })

    describe('readVaultFromPath', () => {
        const config = {
            app_role: 'AppRole',
            app_secret_id: 'secretId'
        }

        it('iterates over paths, and returns a new config', async () => {
            const options = {
                enabled: true,
                url: {value: 'https://vault.agro.services'},
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'app_role'},
                    secretId: {inConfig: 'app_secret_id'}
                },
                paths: {testA: 'secret/stuff/a'}
            }
            const data = await processors.readVaultFromPaths(options)(config)
            data.should.eql({
                app_role: 'AppRole',
                app_secret_id: 'secretId',
                testA: {direct: 'a'}
            })
        })

        it('throws if options fail to generate a vault client', async () => {
            vaultCF.getVault.restore()
            const params = {
                enabled: true,
                auth: {
                    type: 'appRole',
                    roleId: {inConfig: 'missing_app_role'},
                    secretId: {inConfig: 'missing_app_secret_id'}
                },
                url: {value: 'https://vault.agro.services'}
            }

            try {
                await processors.readVaultFromPaths(params)(config)
                should.fail()
            } catch (err) {
                err.message.should.include('Missing credentials.role_id!')
            }
        })

        it('does nothing if enabled is false', () => {
            vaultCF.getVault.restore()
            const params = {
                url: {value: 'https://vault.agro.services'},
                auth: {
                    roleId: {inConfig: 'missing_app_role'},
                    secretId: {inConfig: 'missing_app_secret_id'}
                },
                enabled: false
            }

            return Promise.resolve()
                .then(() => processors.readVaultFromPaths(params)(config))
                .then((data) => data.should.eql(config))
        })
    })

    describe('writeToFile', () => {
        const config = {
            demo: true,
            superSecret: 'value'
        }
        const filepath = path.resolve(__dirname, '../../files/writeTest.json')

        it('writes to a directory', () =>
            processors
                .writeToFile({enabled: true, output: filepath})(config)
                .then(() => {
                    const data = fs.readFileSync(filepath, 'utf8')
                    JSON.parse(data).should.eql(config)
                }))

        it("removes fields with 'omit'", () =>
            processors
                .writeToFile({enabled: true, output: filepath, omit: ['superSecret']})(config)
                .then(() => {
                    const data = fs.readFileSync(filepath, 'utf8')
                    JSON.parse(data).should.eql({demo: true})
                }))

        it("selects fields with 'only'", () =>
            processors
                .writeToFile({enabled: true, output: filepath, only: ['demo']})(config)
                .then(() => {
                    const data = fs.readFileSync(filepath, 'utf8')
                    JSON.parse(data).should.eql({demo: true})
                }))

        it('throws on invalid paths', () =>
            processors
                .writeToFile({enabled: true, output: './invalid/path', only: ['demo']})(config)
                .then(() => should.fail())
                .catch((err) => {
                    err.message.should.include('ENOENT: no such file or directory')
                }))
    })

    describe('inspect', () => {
        const config = {
            deeply: {
                nested: {
                    value: true
                }
            }
        }
        beforeEach(() => {
            sinon.stub(console, 'info')
            sinon.stub(console, 'warn')
        })
        afterEach(() => {
            console.info.restore()
            console.warn.restore()
        })
        it('logs the path provided', () => {
            processors.inspect('deeply')(config)
            console.info.calledWith("Value for 'deeply'", {nested: {value: true}})
        })

        it('deeply accesses the config', () => {
            processors.inspect('deeply.nested.value')(config)
            console.info.calledWith("Value for 'deeply.nested.value'", true)
        })

        it('warns when no value is present', () => {
            processors.inspect('very.deeply.nested.value')(config)
            console.warn.calledWith("No value found at 'very.deeply.nested.value'")
        })
    })
})
