# Config

A central configuration store for your application.

---

Configuration can be complex.

* A 12 factor app will provide configuration as environment variables.
* On Cloudfoundry, configuration will come from service-bindings, provided as a
deeply nested JSON object on VCAP_SERVICES.
* On fargate, configuration will likely come from paths in the parameter store.
* Some apps will have a serviceBindings file with static, or default configuration.
* And after all your configuration is combined, you may need to then resolve
credentials from vault at runtime.

So an applications's config can come from all over the place. The goal of this
library is to centralize all the work around gathering configuration, and provide
hooks that describe where to look, and how to resolve that configuration.

## Installation
``` bash
npm i @monsantoit/config
```

## Example Usage

Below is a configuration store where we:

1. Source configuration from a local js file

1. Source configuration from cloudfoundry bindings.

1. Merge them together.

1. Iterate over the resulting config, searching for vault URI's (`vault://`), and replacing them with values from vault.

``` javascript
const path = require('path')
const { Config, source, processor} = require('@monsantoit/config')

module.exports = new Config({
    sources: [
        source.fromJS({ src: path.resolve(__dirname, `./static-config.js`) }),
        source.fromCloudFoundry(),
    ],
    processors: [
        processor.readVaultFromConfig({
            auth: {
                type: 'appRole',
                roleId: process.env.APP_VAULT_ROLE_ID,
                secretId: process.env.APP_VAULT_SERET_ID
            }
        })
    ]
})
```

We initalize our config, waiting for our async configuration to resolve
before we start our application.
```js
const config = require('./path/to/config')

config.init().then(() => require('./path/to/app'))
```

Once initialized, we can fetch config credentials and options inside our application.
``` javascript

const config = require('./path/to/config')
const db = require('./db')

module.exports = db(config.get('database.credentials'))
```

## Bootstrapping

It's assumed that configuration gathering will be an asynchronous process.
To ensure all data is present when called, boostrap your config module **before
requiring your application.**

``` javascript
const config = require('./path/to/config')

config.init().then((config) => {
    // require your app here.
    require('./path/to/app').start(config)
})
.catch((err) => {
    console.error(err)
    process.exit(1)
})

```
When you require a module in node, it also loads that module's required files,
and _those_ module's required files, running any and all functions in global scope.

If any of these functions attempt to fetch from your config, values may not be
present and resolved yet. Doing so will throw an error.

Once initialized, your resolved config should be available synchronously from the store.
Using `.get`, you can provide a path to the value you're looking for.

``` javascript
const config = require('./path/to/config/store')
const pg = require('some-postgres-module')

const creds = config.get('database.credentials')
const client = pg.client(creds)
```

## Setup - Create your config
The following options are available when generating a `new Config`

### sources (Array[Function])

Sources should be a list of functions that either return an object, or a promise that resolves an object. All sources are resolved concurrently. Several sources are provided, and appear below.

- Sources [all](/sources)
    - [fromJS](/sources/#sourcefromjs)
    - [fromFile (json or yaml)](/sources/#sourcefromfile)
    - [fromCloudFoundry](/sources/#sourcefromcloudfoundry)
    - [fromEnvironment](/sources/#sourcefromenvironment)

#### Writing your own sources

Here's an examples source for a quick and dirty file parser:
``` javascript
const fs = require('fs')
const readFile = (pathToFile) => {
    return () => JSON.parse(fs.readFileSync(pathToFile, 'utf8'))
}

// Then, in your config
new Config({
    sources: [
        readFile('./someFile'),
        readFile('./someOtherFile')
    ]
})
```

### processors (Array[Function])

Processors take the sourced and merged configuration, and do additional work to the result.
All processors are resolved sequentially in the order provided. A number of processors
are provided by default.

- Processors [all](/processors)
    - [readParamStoreFromConfig](/processors/#processorreadparamstorefromconfig)
    - [readVaultFromConfig](/processors/#processorreadvaultfromconfig)
    - [readVaultFromPaths](/processors/#processorreadvaultfrompaths)
    - [writeToFile](/processors/#processorwritetofile)
    - [inspect](/processors/#processorsinspect)


#### Writing your own processors
Processors should return a function which takes a config object, and returns
either the updated configuration object, or a promise that resolves
the updated configuration.

Here's some sample code for a processor that filters out noisy keys
from a config:
``` javascript
const _ = require('lodash')
const filter = (keys) => (config) => _.omit(config, keys)

// in your config
new Config({
    source: [
        sources.fromCloudFoundry(),
    ]
    processors: [
        filter(['thisKey', 'thatKey'])
    ]
})

```

A processor that outputs the current value of a key for the config (inspect is included by default)
``` javascript
const get = require('lodash/get')

const inspect = (key) => (config) => {
    console.log(`Value for ${key}`, get(config, key)
    return config
}

// in your config
new Config({
    source: [
        sources.fromCloudFoundry(),
    ]
    processors: [
        inspect('some.key') // logs value in { some { key: `value` } }
    ]
})
```

### required (Array[String])
`required` is a list of keys that must be present before bootstrapping your application. If any keys are missing, it throws an error.

Currently, checks only the top level keys.

### verbose (Boolean)
When set to true, `verbose` outputs the current configuration at each step.

### autoRefresh (Boolean)
When set to true, will automatically refresh the config values. Useful for updating vault values or aws param store values

Defaults to false

### autoRefreshInterval (Integer)
When set to a value `N`, every `N` minutes, the config will be refreshed and pull updated values from the processors. the `autoRefresh` option must be set to true for this to take effect

Defaults to 15, Minimum 1~~~~

---

## In App Usage

The following methods are available on a Config instance.

### Config.init
Initializes the configuration. Configuration will not be available until complete.

``` javascript
const config = require('./path/to/config')
// initialize config at the top of your app.
config.init().then((data) => {
    // do not require your app until the configuration is loaded.
    // otherwise, early calls for unresolved values may result in errors.
    require('./path/to/app/').start(data)
})
.catch((err) => {
    // log validation errors, vault errors, and more.
    console.log(err)
    process.exit(1)
})
```

### Config.get
Gets a value from configuration. Can resolve deep paths with dot-notation, and accepts a default value if the value is missing.

If the config is not yet initialized, `get` throws an error.

```js
const config = require('./path/to/config')

const shallow = config.get("something")
const deep = config.get("path.to.data")
const withDefault = config.get("missingData", "defaultValue")
```

### Config.set
Sets a value within configuration. Can resolve deep paths with dot-notation. Returns the set value.

If the config is not yet initialized, `set` throws an error.

``` javascript
const config = require('./path/to/config')

config.set("something", "value")
config.set("path.to.data", "value")
```

### Config.stopRefresh
Cancels the refreshing of the config if enabled
