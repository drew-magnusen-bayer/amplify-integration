const expect = require("chai").expect
const sinon = require("sinon")
const randomString = require("random-string")
const failoverAuthorizedAgent = require("../../lib/failoverAuthorizedAgent")
const vaultAuthorizer = require("../../lib/vaultAuthorizer")
const agent = require("superagent")

const { azureConfig } = require("../loadConfig")

const clearEnv = () => {
  const pingVariables = ["ENVIRONMENT", "CLIENT_ID", "VAULT_SECRET_PATH", "VAULT_ROLE"]
  pingVariables.forEach((variable) => delete process.env[variable])
}

describe("failoverAuthorizedAgent", () => {
  describe("with azure", () => {
    beforeEach(() => {
      process.env.ENVIRONMENT = azureConfig.environment
      process.env.CLIENT_ID = azureConfig.clientId
      process.env.VAULT_SECRET_PATH = azureConfig.vaultSecretPath
      process.env.VAULT_ROLE = azureConfig.vaultRole
    })

    it("gets url successfully", async () => {
      const results = await failoverAuthorizedAgent.get(azureConfig.endpoint, {
        authProvider: "azure",
      })

      expect(results.body.length).to.equal(1)
    })

    it("gets url successfully using parameters", async () => {
      clearEnv()

      const url = "https://velocity-np.ag/ip/aplus-result?sequenceName=197:1"
      const results = await failoverAuthorizedAgent.get(url, {
        environment: azureConfig.environment,
        clientId: azureConfig.clientId,
        vaultSecretPath: azureConfig.vaultSecretPath,
        vaultRole: azureConfig.vaultRole,
        authProvider: "azure",
      })

      expect(results.body.length).to.equal(1)
    })

    it("gets url successfully specifying auth provider", async () => {
      const url = azureConfig.endpoint

      const results = await failoverAuthorizedAgent.get(url, { authProvider: "azure" })

      expect(results.body.length).to.be.greaterThan(0)
    })

    it("gets url successfully using azure environment variables", async () => {
      clearEnv()
      process.env.AZURE_CLIENT_ID = azureConfig.clientId
      process.env.AZURE_VAULT_SECRET_PATH = azureConfig.vaultSecretPath
      process.env.AZURE_VAULT_ROLE = azureConfig.vaultRole
      const url = azureConfig.endpoint
      const index = require("../../lib/index")

      const results = await index.azureAgent.get(url)

      expect(results.body.length).to.equal(1)
    })

    it("gets url successfully using azure environment variables when both sets specified", async () => {
      process.env.CLIENT_ID = randomString()
      process.env.VAULT_SECRET_PATH = randomString()
      process.env.VAULT_ROLE = randomString()

      process.env.AZURE_CLIENT_ID = azureConfig.clientId
      process.env.AZURE_VAULT_SECRET_PATH = azureConfig.vaultSecretPath
      process.env.AZURE_VAULT_ROLE = azureConfig.vaultRole
      const url = azureConfig.endpoint
      const index = require("../../lib/index")

      const results = await index.azureAgent.get(url)

      expect(results.body.length).to.equal(1)
    })

    it("gets url successfully using regular environment variables when no azure ones specified", async () => {
      delete process.env.AZURE_CLIENT_ID
      delete process.env.AZURE_VAULT_SECRET_PATH
      delete process.env.AZURE_VAULT_ROLE
      const url = azureConfig.endpoint
      const index = require("../../lib/index")

      const results = await index.azureAgent.get(url)

      expect(results.body.length).to.equal(1)
    })

    it("wraps errors", async () => {
      try {
        await failoverAuthorizedAgent.post(
          "https://api-t.monsanto.com/pollux-client/wsdl-adapter/services/invoke/",
          { authProvider: "azure" },
          {
            wsdl: "http://tps-t.monsanto.com/pipelinemgmt/services/WorkplanService?wsdl",
            method: "WorkplanServiceService",
            endpoint: "WorkplanServicePort",
            operation: "submitToTransformation",
            wsSecurityUsername: "SRGROD",
            body: { _xml: "<invalidXmlTag></invalidXmlTag>" },
          }
        )
        throw new Error("Error not thrown")
      } catch (error) {
        expect(error.message).to.have.string(
          "Message part invalidXmlTag was not recognized.  (Does it exist in service WSDL?)"
        )
      }
    })

    describe("with superagent mocked", () => {
      let mockGet, url, mockDel, mockPatch

      beforeEach(() => {
        delete require.cache[require.resolve("../../lib/index")]
        mockGet = sinon.stub(agent, "get")
        mockDel = sinon.stub(agent, "delete")
        mockPatch = sinon.stub(agent, "patch")

        url = azureConfig.endpoint
      })

      afterEach(() => {
        mockGet.restore()
        mockDel.restore()
        mockPatch.restore()
      })

      it("calls del with error thrown", async () => {
        const index = require("../../lib/index")
        const expectedError = new Error(randomString())
        mockDel.throws(expectedError)

        try {
          await index.azureAgent.del(url, {}, { [randomString()]: randomString() })
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error).to.equal(expectedError)
          expect(mockDel.callCount).to.equal(1)
          expect(mockDel.lastCall.args[0]).to.equal(url)
        }
      })

      it("calls patch with error thrown", async () => {
        const index = require("../../lib/index")
        const expectedError = new Error(randomString())
        mockPatch.throws(expectedError)

        try {
          await index.azureAgent.patch(url)
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error).to.equal(expectedError)
          expect(mockPatch.callCount).to.equal(1)
          expect(mockPatch.lastCall.args[0]).to.equal(url)
        }
      })

      it("throws error when error making service call", async () => {
        const index = require("../../lib/index")

        const expectedError = new Error(randomString())
        mockGet.throws(expectedError)

        try {
          await index.azureAgent.get(url)
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error).to.equal(expectedError)
        }
      })

      const setupAgentFailure = (expectedError) => {
        const failedPromise = sinon.stub()
        mockGet.returns({ set: sinon.stub().returns({ set: failedPromise }) })
        failedPromise.rejects(expectedError)
      }

      it("returns error text when service call returns error", async () => {
        const index = require("../../lib/index")
        const expectedErrorMessage = randomString()
        const expectedError = new Error()
        expectedError.response = {
          statusCode: 400,
          text: expectedErrorMessage,
        }
        setupAgentFailure(expectedError)

        try {
          await index.azureAgent.get(url)
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error.message).to.equal(expectedErrorMessage)
        }
      })

      it("returns error body when service call returns error", async () => {
        const index = require("../../lib/index")
        const expectedErrorMessage = { error: randomString() }
        const expectedError = new Error()
        expectedError.response = {
          statusCode: 400,
          body: expectedErrorMessage,
        }
        setupAgentFailure(expectedError)

        try {
          await index.azureAgent.get(url)
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error.message).to.equal(JSON.stringify(expectedErrorMessage))
        }
      })

      it("returns static error message when no response body", async () => {
        const index = require("../../lib/index")
        const expectedError = new Error()
        expectedError.response = {
          statusCode: 500,
          body: "",
        }
        setupAgentFailure(expectedError)

        try {
          await index.azureAgent.get(url)
          throw new Error("Error not thrown")
        } catch (error) {
          expect(error.message).to.equal(`Response status code is 500`)
        }
      })
    })
  })

  describe("getToken", () => {
    let vaultAuthMock
    const defaultArgs = {
      clientId: randomString(),
      environment: randomString(),
      vaultSecretPath: randomString(),
      vaultRole: randomString(),
      clientSecret: randomString(),
    }

    beforeEach(() => {
      process.env.ENVIRONMENT = defaultArgs.environment
      process.env.CLIENT_ID = defaultArgs.clientId
      process.env.VAULT_SECRET_PATH = defaultArgs.vaultSecretPath
      process.env.VAULT_ROLE = defaultArgs.vaultRole
      process.env.CLIENT_SECRET = defaultArgs.clientSecret

      vaultAuthMock = sinon.stub(vaultAuthorizer, "authorize")
    })

    afterEach(() => {
      sinon.restore()
    })

    it("should used passed in 'clientId' instead of environment variable if supplied", async () => {
      const args = { clientId: randomString() }
      await failoverAuthorizedAgent.getToken(args)

      return expect(vaultAuthMock.firstCall.firstArg).to.deep.equal({
        ...defaultArgs,
        ...args,
      })
    })

    it("should used passed in 'environment' instead of environment variable if supplied", async () => {
      const args = { environment: randomString() }
      await failoverAuthorizedAgent.getToken(args)

      return expect(vaultAuthMock.firstCall.firstArg).to.deep.equal({
        ...defaultArgs,
        ...args,
      })
    })

    it("should used passed in 'vaultSecretPath' instead of environment variable if supplied", async () => {
      const args = { vaultSecretPath: randomString() }
      await failoverAuthorizedAgent.getToken(args)

      return expect(vaultAuthMock.firstCall.firstArg).to.deep.equal({
        ...defaultArgs,
        ...args,
      })
    })

    it("should used passed in 'vaultRole' instead of environment variable if supplied", async () => {
      const args = { vaultRole: randomString() }
      await failoverAuthorizedAgent.getToken(args)

      return expect(vaultAuthMock.firstCall.firstArg).to.deep.equal({
        ...defaultArgs,
        ...args,
      })
    })

    it("should used passed in 'clientSecret' instead of environment variable if supplied", async () => {
      const args = { clientSecret: randomString() }
      await failoverAuthorizedAgent.getToken(args)

      return expect(vaultAuthMock.firstCall.firstArg).to.deep.equal({
        ...defaultArgs,
        ...args,
      })
    })
  })
})
