const traverse = require('traverse');
const _ = require('underscore');

const vaultUriPrefix = 'vault://';

function extractVaultKey(uri) {
	const attributeIndex = uri.lastIndexOf('/');
	const attribute = uri.substr(attributeIndex + 1);
	const key = uri.substr(vaultUriPrefix.length, (uri.length - vaultUriPrefix.length) - (uri.length - attributeIndex));
	return {key, attribute};
}

function evaluateVaultKey(vault, key, targetAttributes) {
	// node vault requires paths as per the rest api, rather then the CLI
	// The API for the kv backend requires extra path values.
	// the below formatting keeps secret paths aligned with the CLI, and closer
 	// to the typical dev experience.

	let formattedKey = key.startsWith('kv/') && !key.startsWith('kv/data/') ? key.replace('kv/', 'kv/data/') : key

	return vault.read(formattedKey).then(({data}) => {
		targetAttributes.forEach((targetAttribute) => {
			if (key.startsWith('kv')) {
        		targetAttribute.node.update(data.data[targetAttribute.attribute]);
			} else
    		{
        		targetAttribute.node.update(data[targetAttribute.attribute]);
    		}
		});
	}).catch((err) => {
		throw new Error(`Unable to read vault key: ${key}.  Reason: ${err}`);
	});
}
function injectVault(obj, vault) {
	let toTransform = [];
	traverse(obj).forEach(function(val) {
		const node = this;
		if(node.isLeaf) {
			if(_(val).isString() && val.startsWith(vaultUriPrefix)){
				const {key, attribute} = extractVaultKey(val);
				const params = {node, key, attribute};
				toTransform.push(params);
			}
		}
	});
	const grouped = _(toTransform).groupBy('key');
	const promises = Object.keys(grouped).map((key) => {
		return evaluateVaultKey(vault, key, grouped[key]);
	});
	return Promise.all(promises);
}

module.exports = injectVault;