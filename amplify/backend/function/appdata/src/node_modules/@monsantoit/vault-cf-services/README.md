# Vault CloudFoundry Service Integration
```bash
npm i --save @monsantoit/vault-cf-services
```

The purpose of this is to make it easy to integrate Vault to replace your cloud foundry bindings without having to rewrite your code.

This README includes step by step instructions and examples, however you can skip down to the Library section if you just want to use the direct library functions.

## Motivation
 Let's start by assuming we have an existing application with cloud foundry bindings like so:
 ```json
[
  {
    "alias": "ping-info",
    "clientId": "myClientId",
    "secret": "sssssssh"
  },
  {
    "alias": "db-info",
    "dbUser": "myDbUser",
    "password": "12345"
  }
]
```

Usually in your code, you will grab the VCAP_SERVICES env and tranform it into JSON.  The most common way using the [@monsantoit/cloud-foundry](https://npm-web.platforms.engineering/package/@monsantoit/cloud-foundry) library.  For example:
 ```javascript
const services = require('@monsantoit/cloud-foundry').services;

const {dbUser, password} = services['db-info'];
```
You might have that scattered all throughout your code, so replacing that with something that retrieves from Vault doesn't look appealing.

The purpose of this library is that you **don't have to change that piece of code at all**.  We want to inject the Vault info into that common services in a way that it goes unnoticed by the rest of your project.

Let's look at how we can do that.

## Step By Step Instructions
### Getting your info into Vault
If you haven't gotten set up with Vault, then [follow these instructions first](https://help.platforms.engineering/19-vault/).

First off you'll want to put your settings into Vault (please use your own values for myarea, myapp)
```bash
vault write secret/myarea/myapp/pinginfo clientid=myClientId secret=sssssssh
vault write secret/myarea/myapp/dbinfo dbuser=myDbUser password=12345
```

Now you're going to need an AppRole so your app can access Vault.  You can request one in the #vault slack channel, make sure to specify it needs access to secret/myarea/myapp/*.  Once it's setup, [retreive the role id and secret id](https://www.vaultproject.io/docs/auth/approle.html#fetch-the-roleid-of-the-approle).

### Setting up your Cloud Foundry environment
While you have that data, let's go ahead and create the cloud foundry binding for it.  While we're at it, let's create the binding for our vault server url as well.
```bash
cf cups myapp-approle -p '{"alias": "myapp-approle", "role_id": "MYAPPROLEID", secret_id: "MYAPPROLESECRETID"}'
cf cups vault-server -p '{"alias": "vault-server","url": "https://vault.agro.services"}'
```

Now it's time to replace the ping & db sensitive data with paths to vault.
```bash
cf uups ping-info -p '{"alias": "ping-info", clientId: "vault://secret/myarea/myapp/pinginfo/clientid", secret: "vault://secret/myarea/myapp/pinginfo/secret"}'
cf uups db-info -p '{"alias": "db-info", dbUser: "vault://secret/myarea/myapp/dbinfo/dbuser", password: "vault://secret/myarea/myapp/dbinfo/password"}'

```
Our target bindings will end up looking like this:
```json
[
  // non versioned secrets are under 'secret'.
  {
    "alias": "ping-info",
    "clientId": "vault://secret/myarea/myapp/pinginfo/clientid",
    "secret": "vault://secret/myarea/myapp/pinginfo/secret"
  },
  // Versioned secrets are under 'kv'.
  {
    "alias": "db-info",
    "dbUser": "vault://kv/myarea/myapp/dbinfo/dbuser",
    "password": "vault://kv/myarea/myapp/dbinfo/password"
  },
]
```
**Note**: In this URI format, the last part of the path is the target attribute on the vault key path.

### Modifying your Node.JS project
You need to install the [@monsantoit/vault-cf-services](https://npm-web.platforms.engineering/package/@monsantoit/vault-cf-services) package.
```bash
npm i --save @monsantoit/vault-cf-services
```

If you're using a standard express setup, or something from the velocity code generator (or copied from another project), you will have a *bin/www* file.  If not, look for the thing that is loading up your main server/app.js code.

Typically, the bin/www file looks like this:
```javascript
#!/usr/bin/env node
if ( process.env.NODE_ENV !== 'production' ) {
  if (
    !require('piping')({ hook: true, ignore: /(public)/ })
  ) {
    return;
  }
}

require('../server');
```
That last *require('../server')* is what starts our node server, and is going to be where we make our change.  In this example, we're assuming you're using the @monsantoit/cloud-foundry package to get your service bindings, but you should easily be able to inject your own thing here.
```javascript
#!/usr/bin/env node
if ( process.env.NODE_ENV !== 'production' ) {
  if (
    !require('piping')({ hook: true, ignore: /(public)/ })
  ) {
    return;
  }
}

const services = require('@monsantoit/cloud-foundry').services;
const {injectVaultIntoCloudFoundryServices} = require('@monsantoit/vault-cf-services');

const url = services['vault-server'].url // your vault server url
const role = services['papi-routes-approle'] // your app role info we added earlier
injectVaultIntoCloudFoundryServices(url, role, services)
.then(() => {
    require('../server');
}).catch((err) => {
    console.log('Error: ', err);
    process.exit();
});
```
And that's all the code you have to change!  We have to have the injection happen before we start the server to make sure everything is ready.
At this point, usages of *require('@monsantoit/cloud-foundry').services* will have the correct vault values injected.  The library actually mutates that object when it does it's injection.

Make sure in your cf-deploy.js you include the new service bindings for **vault-server** and **myapp-approle**.

You are now ready to deploy your app, and it will retrieve your confidential data from Vault.

## Library
While the **injectVaultIntoCloudFoundryServices** makes it easy to inject Vault in one step, you might need to use the other pieces of library for various reasons, so we've exposed them as well.
### getAppRoleToken(vaultUrl, credentials)
This will query vault for the AppRole client token, and caches it until 30 seconds before lease expires.  The credentials object must have the following format:
```json
{
  "role_id": "ROLEID",
  "secret_id": "SECRETID"
}
```

### getVault(vaultUrl, credentials)
Uses the same vaultUrl and credentials above, and return a [node-vault](https://www.npmjs.com/package/node-vault) client.  It will cache the client until the token expires, then return a new one.

Note that the vaultUrl and credentials are **only required for the first call**.  It caches those values so future calls can just call it with empty parameters.

### injectVaultIntoObject(obj, vault)
Will traverse the object and replace any vault:// paths with the actual vault value.

### getVaultResolvedCloudFoundryServices(vaultUrl, credentials)
Alternative way to get the service bindings.  In this case, it utilizes @monsantoit/cloud-foundry internally to get the Cloud Foundry service bindings, transforms them, then returns the transformed object.

### injectVaultIntoCloudFoundryServices(vaultUrl, credentials, serviceBindings)
Your one stop shop to inject into your service bindings, and how we recommend you use the library.