const retrieveCredentials = require("../../lib/retrieveCredentials")
const randomString = require("random-string")
const expect = require("chai").expect
const vaultCfServices = require("@monsantoit/vault-cf-services")
const vaultClient = require("../../lib/vaultClient")
const sinon = require("sinon")

describe("retrieveCredentials", () => {
  describe("retrieve", () => {
    it("throws when clientId not provided", async () => {
      try {
        await retrieveCredentials.retrieve({})
        throw new Error("no error thrown")
      } catch (err) {
        expect(err.message).to.equal("clientId is required!")
      }
    })

    it("throws when environment not provided and no auth provider", async () => {
      try {
        await retrieveCredentials.retrieve({ clientId: randomString() })
        throw new Error("no error thrown")
      } catch (err) {
        expect(err.message).to.equal("environment is required!")
      }
    })

    it("throws when environment not provided and auth provider is ping", async () => {
      try {
        await retrieveCredentials.retrieve({ clientId: randomString(), authProvider: "ping" })
        throw new Error("no error thrown")
      } catch (err) {
        expect(err.message).to.equal("environment is required!")
      }
    })

    it("throws when vaultRole not provided when no client secret supplied", async () => {
      try {
        await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
        })
        throw new Error("no error thrown")
      } catch (err) {
        expect(err && err.message).to.equal("vaultRole is required!")
      }
    })

    it("throws when vaultSecretPath not provided when no client secret supplied", async () => {
      try {
        await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
          vaultRole: randomString(),
        })
        throw new Error("no error thrown")
      } catch (err) {
        expect(err.message).to.equal("vaultSecretPath is required!")
      }
    })

    it("doesn't throw when vaultRole not provided and client secret supplied", async () => {
      try {
        const results = await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
          clientSecret: randomString(),
        })
        expect(results).to.exist
      } catch (err) {
        throw new Error("error thrown")
      }
    })

    it("doesn't throw when vaultSecretPath not provided and client secret supplied", async () => {
      try {
        const results = await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
          clientSecret: randomString(),
        })

        expect(results).to.exist
      } catch (err) {
        throw new Error(err)
      }
    })

    it("retrieves secret", async () => {
      const params = {
        clientId: randomString(),
        environment: "np",
        vaultSecretPath: randomString(),
        vaultRole: "pipeline-dev-team-smartsheet-services-local",
      }

      const credentials = await retrieveCredentials.retrieve({ ...params })

      expect(credentials.CLIENT_ID).to.equal(params.clientId)
      expect(credentials.PING_URL).to.equal("https://test.amp.monsanto.com/as/token.oauth2")
      expect(credentials.CLIENT_SECRET).to.exist
      expect(credentials.CLIENT_SECRET.length).to.be.greaterThan(0)
    })

    it("retrieves secret with azure", async () => {
      const params = {
        clientId: randomString(),
        vaultSecretPath: randomString(),
        vaultRole: "pipeline-dev-team-smartsheet-services-local",
      }

      const credentials = await retrieveCredentials.retrieve({ ...params, authProvider: "azure" })

      expect(credentials.CLIENT_ID).to.equal(params.clientId)
      expect(credentials.AZURE_URL).to.equal(
        "https://login.microsoftonline.com/fcb2b37b-5da0-466b-9b83-0014b67a7c78/oauth2/v2.0/token"
      )
      expect(credentials.CLIENT_SECRET).to.exist
      expect(credentials.CLIENT_SECRET.length).to.be.greaterThan(0)
    })

    describe("with vault mocked", () => {
      let mockInject, mockCreate

      beforeEach(() => {
        mockCreate = sinon.stub(vaultClient, "create")
        mockInject = sinon.stub(vaultCfServices, "injectVaultIntoObject")
      })

      afterEach(() => {
        mockCreate.restore()
        mockInject.restore()
      })

      it("throws when error connecting to vault", async () => {
        const expectedError = new Error(randomString())
        mockCreate.rejects(expectedError)

        try {
          await retrieveCredentials.retrieve({
            clientId: randomString(),
            environment: randomString(),
            vaultSecretPath: "vault://secret/pipeline/workflowinator/np/CLIENT_SECRET",
            vaultRole: "pipeline-dev-team-smartsheet-services-local",
          })
          throw new Error("no error thrown")
        } catch (err) {
          expect(err).to.equal(expectedError)
        }
      })

      it("throws when error retrieving vault secret", async () => {
        const expectedError = new Error(randomString())
        mockInject.rejects(expectedError)

        try {
          await retrieveCredentials.retrieve({
            clientId: randomString(),
            environment: randomString(),
            vaultSecretPath: "vault://secret/pipeline/workflowinator/np/CLIENT_SECRET",
            vaultRole: "pipeline-dev-team-smartsheet-services-local",
          })
          throw new Error("no error thrown")
        } catch (err) {
          expect(err).to.equal(expectedError)
        }
      })

      it("shouldn't create a Vault client if a clientSecret has been supplied", async () => {
        await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
          clientSecret: randomString(),
        })

        expect(mockCreate.called).to.be.false
      })

      it("shouldn't call Vault services if a clientSecret has been supplied", async () => {
        await retrieveCredentials.retrieve({
          clientId: randomString(),
          environment: randomString(),
          clientSecret: randomString(),
        })

        expect(mockInject.called).to.be.false
      })
    })
  })
})
