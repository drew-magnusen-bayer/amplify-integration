const injectVault = lib.require('injectVaultIntoObject');

describe('inject vault', () => {
	let {vault} = {};
	beforeEach(() => {
		vault = {
			read: sinon.stub()
		};
		vault.read.withArgs('secret/stuff').resolves({data: {a: 'A', b: 'B'}});
		vault.read.withArgs('secret/other').resolves({data: {c: 'C', d: 'D'}});
		vault.read.withArgs('kv/data/stuff').resolves({data: {data: {foo: 'bar', d: 'D'}}});
	});

	it('simple replacement', () => {
		const obj = {
			key1: 'vault',
			key2: 'vault://secret/stuff/a'
		};
		const expected = {
			key1: 'vault',
			key2: 'A'
		};
		return injectVault(obj, vault).then(() => {
			obj.should.eql(expected);
		});
	});

   	it('kv replacement without data in path', () => {
    	const obj = {
        	key1: 'vault',
        	key2: 'vault://kv/stuff/foo'
    	};
		const expected = {
    		key1: 'vault',
    		key2: 'bar'
		};
		return injectVault(obj, vault).then(() => {
    		obj.should.eql(expected);
		});
	});

	it('kv replacement with data in path', () => {
    	const obj = {
        	key1: 'vault',
        	key2: 'vault://kv/data/stuff/foo'
    	};
		const expected = {
    		key1: 'vault',
    		key2: 'bar'
		};
		return injectVault(obj, vault).then(() => {
    		obj.should.eql(expected);
		});
	});

	it('multi-level-replacement, optimizing number of calls to vault', () => {
		const obj = {
			key1: 'vault',
			key2: 'vault://secret/stuff/a',
			parent1: {
				parent2: {
					key3: 'vault://secret/stuff/b',
					key4: 'vault://secret/other/c',
				},
				key5: 'vault://secret/other/d'
			}
		};
		const expected = {
			key1: 'vault',
			key2: 'A',
			parent1: {
				parent2: {
					key3: 'B',
					key4: 'C'
				},
				key5: 'D'
			}
		};
		return injectVault(obj, vault).then(() => {
			obj.should.eql(expected);
			vault.read.callCount.should.equal(2);
		});
	});
});