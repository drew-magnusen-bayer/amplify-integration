const vaultAuthorizer = require("../../lib/vaultAuthorizer")
const expect = require("chai").expect
const sinon = require("sinon")
const addAuthorization = require("../../lib/addAuthorization")
const randomString = require("random-string")
const retrieveCredentials = require("../../lib/retrieveCredentials")

const { azureConfig } = require("../loadConfig")

describe("vaultAuthorizer", () => {
  describe("authorize", () => {
    const params = {
      clientId: azureConfig.clientId,
      environment: azureConfig.environment,
      vaultRole: azureConfig.vaultRole,
      vaultSecretPath: azureConfig.vaultSecretPath,
      authProvider: "azure",
    }

    describe("with azure mocks", () => {
      let authorizeMock, retrieveMock, creds

      beforeEach(() => {
        authorizeMock = sinon.stub(addAuthorization, "azureAuthorize")
        retrieveMock = sinon.stub(retrieveCredentials, "retrieve")
        creds = { [randomString()]: randomString() }
        retrieveMock.resolves(creds)
      })

      afterEach(() => {
        authorizeMock.restore()
        retrieveMock.restore()
      })

      it("successfully obtains token after retry", async () => {
        authorizeMock.onFirstCall().rejects()
        const expectedToken = randomString()
        authorizeMock.onSecondCall().resolves(expectedToken)

        const result = await vaultAuthorizer.authorize(params, 1)

        expect(result).to.equal(expectedToken)
        expect(authorizeMock.lastCall.args[0]).to.deep.equal(creds)
      })

      it("throws after exceeding max retries", async () => {
        const expectedError = new Error(randomString())
        authorizeMock.rejects(expectedError)
        try {
          await vaultAuthorizer.authorize(params, 1)
          throw new Error("Did not throw")
        } catch (error) {
          expect(error).equal(expectedError)
        }
      })

      it("caches vault credentials when no errors", async () => {
        const expectedToken = randomString()
        authorizeMock.resolves(expectedToken)

        const result1 = await vaultAuthorizer.authorize(params, 1)
        const result2 = await vaultAuthorizer.authorize(params)

        expect(retrieveMock.callCount).to.equal(1)
        expect(result1).to.equal(expectedToken)
        expect(result2).to.equal(expectedToken)
      })

      it("reloads cached credentials when error authorizing", async () => {
        authorizeMock.onFirstCall().rejects()
        const expectedToken = randomString()
        authorizeMock.onSecondCall().resolves(expectedToken)
        authorizeMock.onThirdCall().resolves(expectedToken)

        const result1 = await vaultAuthorizer.authorize(params, 1)
        const result2 = await vaultAuthorizer.authorize(params)

        expect(retrieveMock.callCount).to.equal(2)
        expect(result1).to.equal(expectedToken)
        expect(result2).to.equal(expectedToken)
      })
    })

    describe("with real azure authorization", () => {
      let params

      beforeEach(() => {
        params = {
          authProvider: "azure",
          clientId: azureConfig.clientId,
          environment: azureConfig.environment,
          vaultRole: azureConfig.vaultRole,
          vaultSecretPath: azureConfig.vaultSecretPath,
        }
      })

      it("obtains token successfully", async () => {
        const authorization = await vaultAuthorizer.authorize(params)

        expect(authorization).to.exist
        expect(authorization.length).to.be.greaterThan(1000)
      })

      it("obtains token successfully when given secrets directly", async () => {
        params.clientSecret = azureConfig.clientSecret
        params.vaultSecretPath = ""
        params.vaultRole = ""
        const authorization = await vaultAuthorizer.authorize(params)

        expect(authorization).to.exist
        expect(authorization.length).to.be.greaterThan(1000)
      })
    })
  })
})
