const get = require('lodash/get')
const set = require('lodash/set')
const cloneDeep = require('lodash/cloneDeep')
const schema = require('./schema')

function sourceConfigs(sources, verbose = false) {
    return Promise.all(sources.map((source) => source())).then((configs) => {
        const clonedConfigs = cloneDeep(configs)
        return clonedConfigs.reduce((acc, curr, index) => {
            const next = Object.assign(acc, curr || {})

            if (verbose) {
                console.info(`Source at [${index}] generated: ${JSON.stringify(next, null, 4)}`)
            }

            return next
        }, {})
    })
}

async function processConfigs(processors = [], config = {}, verbose = false) {
    return processors.reduce(async (pendingConfig, processor, index) => {
        const currentConfig = await pendingConfig
        const nextConfig = await processor(currentConfig)

        if (verbose) {
            console.info(
                `Processor at [${index}] generated: ${JSON.stringify(nextConfig, null, 4)}`
            )
        }

        return nextConfig
    }, config)
}

module.exports = class Config {
    constructor(options = {}) {
        const defaults = {sources: [], processors: [], required: [], verbose: false}
        const fullOptions = Object.assign({}, defaults, options)

        const {error, value} = schema.validate(fullOptions, schema.forConstructor())

        if (error) {
            throw error
        }

        if (options.autoRefresh === true) {
            this.refreshMillis = (parseInt(options.autoRefreshInterval) || 15) * 60 * 1000 // default 15 minutes
            this.refreshInterval = null
        }
        this.sources = value.sources
        this.processors = value.processors
        this.required = value.required
        this.verbose = value.verbose

        this.initalized = false
        this.config = {}
    }

    async init() {
        this.config = await sourceConfigs(this.sources, this.verbose)
        this.config = await processConfigs(this.processors, this.config, this.verbose)

        const {error} = schema.validate(Object.keys(this.config), schema.forRequired(this.required))

        if (error) {
            throw error
        }

        this.initalized = true

        if (this.refreshMillis) {
            this.refreshInterval = setInterval(async () => {
                try {
                    if (this.verbose) {
                        console.info('Refreshing Config...')
                    }
                    const newSourceConfig = await sourceConfigs(this.sources, this.verbose)
                    this.config = await processConfigs(
                        this.processors,
                        newSourceConfig,
                        this.verbose
                    )
                    if (this.verbose) {
                        console.info('Config refreshed')
                    }
                } catch (err) {
                    if (this.verbose) {
                        console.error(`Error refreshing Config: ${err.message}`)
                    }
                }
            }, this.refreshMillis)
        }
        return this.config
    }

    stopRefresh() {
        if (this.refreshInterval) {
            clearInterval(this.refreshInterval)
        }
    }

    get(path, defaultValue = null) {
        if (this.initalized) {
            return get(this.config, path, defaultValue)
        }

        throw Error(`Config ${path} fetched before config has been initialized.`)
    }

    set(path, newValue) {
        if (this.initalized) {
            this.config = set(this.config, path, newValue)
            return newValue
        }

        throw Error(`Config ${path} set before config has been initialized.`)
    }
}
