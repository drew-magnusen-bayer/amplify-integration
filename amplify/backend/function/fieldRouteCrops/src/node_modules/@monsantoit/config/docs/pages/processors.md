# Processors
The following processors are provided by default.

## Using your config, to define your processors.

Each processor can take additional configuration. If you'd like to keep all your
configuration in one place, you can use the following notation to reference your
config:

``` js
{inConfig: 'path.to.config.value'}
```

This would, for exaple: let you set one value locally, then defer to cloudfoundry
bindings when deployed.

The `inConfig` key signals to the library that the option should be determined by
the configuration, and the value uses dot-notation to signify where the
configuration lives.

The above example, applied to the object below, would pick the value `true`.
```
{
    path: {
        to: {
            config: {
                value: true // <-- this gets selected.
            }
        }
    }
}
```

> NOTE: Processors take the configuration value at the time it's passed into the processor.
> A vault processor can't read from vault to fetch it's own configuration.


## AWS Processors (Parameter Store)
The following processors run only on AWS, and presume that your current environment
has a role provided to it. They do not accept provided AWS credentials.

### processor.readParameterStoreFromConfig
This processor looks for parameter store URIs in your sourced config, and
fetches the value from AWS SSM. A parameter store URI starts with `awsparam://`, and ends
with the parameter store path.

Full Parameter Store URI Example:
``` bash
awsparam://DevTest/MyApp/database/my-password
# grabs the value under the path /DevTest/MyApp/database/my-password
```

Example usage:
``` js
const {processor, env } = require('@monsantoit/config')


processor.readParameterStoreFromConfig({
    enabled: true // defaults to false, should be set based on env.
})
```


## Vault Processors
There are two vault-based processors - one that inspects the config itself, and one
that injects values at paths.

#### processor.readVaultFromConfig
Similar to `@monsantoit/vault-cf-services`, this processor looks for vault URIs
in your sourced config, and fetches the value from vault.

Vault authentication options are detailed below.

A vault URI starts with `vault://` and ends with the path to the secret.

> NOTE: For versions to config@0.5.0 and earlier, the `kv` backend requires you toprepend your path with `kv/data`, due to vault's API.
> This is super annoying, and has been fixed in config 0.6.0

Example Vault URI:
``` bash
# grabs the secret under the key `client-id`, in the secret path
# `secret/your-team/np/appname/oauth`

# secret backend
vault://secret/your-team/np/appname/oauth/client-id

#kv backend
vault://kv/your-team/np/appname/oauth/client-id

```

Example usage:
``` js
processor.readVaultFromConfig({
    url: 'https://vault.agro.services', // default value. can be omitted
    enabled: true // defaults to false. You should enable processors with `env`.
    auth: {
        type: 'appRole',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### processor.readVaultFromPaths
Iterates over a list of paths, and assigns them to a list of keys.

You can use values from within the configuration, or supply them directly.
``` js
processor.readVaultFromPaths({
    url: 'https://vault.agro.services',
    auth {
        type: 'appRole',
        roleId: { inConfig: 'path.to.roleIdKeyInConfig' },
        secretId: { inConfig: 'path.to.secretIdInConfig' },
    },
    paths: [{
        key: 'database',  secret: '/path/for/database',
        key: 'sqs', secret: '/path/for/sqs/'
    }]
})
```

### Vault Authentication
Vault access requires a token. Tokens can be fetched using your local user,
a approle credentials, or an assumed AWS role.

You can provide options within the configuration, or supply them directly.


#### Auto auth (beta)
* Tries to fetch a local vault token, an approle from config, and an aws role concurrently.
* Works locally, on jenkins, in cloudfoundry, or on AWS.
* Supply all possible options. In the case of conflict, this method prioritizes local, appRole, then AWS role.


``` js
processor.readVaultFromConfig({
    enabled: true,
    auth: {
        type: 'auto',
        roleName: { inConfig: 'path.to.aws_role_name'},
        roleId: { inConfig: 'path.to.role_id'},
        secretId: {inConfig: 'path.to.secret_id'}
    }
})
```

``` js
processor.readVaultFromConfig({
    enabled: true,
    auth: {
        type: 'auto',
        roleName: 'my-team-lambda',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### local token auth
* authenticates using your current vault token.
* has all the access your current user has. You may need to log in again if your access changes.
* will not work when deployed
* requires no additional configuration.

``` js
processor.readVaultFromConfig({
    enabled: env.inDevelopment,
    auth: { type: 'local' }
})
```

#### App Role auth
* authenticates using a supplied role id and secret id
* Role is created/configured in fort-knox
* credentials have to come from _somewhere_.
    * Cloudfoundry bindings,
    * direct environment variables
    * etc.

``` js
processor.readVaultFromConfig({
    enabled: env.inProduction,
    auth: {
        type: 'appRole',
        roleId: process.env.APP_VAULT_ROLE_ID,
        secretId: process.env.APP_VAULT_SECRET_ID,
    }
})
```

#### Aws Role auth
* Authenticates using your current AWS role.
* Role is created/configured in fort-knox.
* No credentials have to be supplied through your app.
* Will not work in cloudfoundry

``` js
processor.readVaultFromConfig({
    enabled: env.inProduction,
    auth: {
        type: 'awsRole',
        roleName: 'my-team-lambda', // this value can be found in fort-knox.
    }
})
```


You'll likely change configuration between local development and deployment.
Your sourced configuration can determine how to authenticate,
use the `inConfig` option.

#### fetch from sourced configuration
``` js
processor.readVaultFromConfig({
    url:  'https://vault.agro.services',
    auth: {
        type: { inConfig: 'path.to.typeInConfig' }          // inConfig property looks for
        roleId: { inConfig: 'path.to.roleIdKeyInConfig' },  // the value within the config,
        secretId: { inConfig: 'path.to.secretIdInConfig' }, // generated by your sources.
    }
})
```


## Debugging Processors
The following processors are useful for debugging any issues with configuration

### processor.writeToFile
Write the current configuration to a file, as JSON, for later inspection. It takes the path as given, you'll need to resolve the path yourself.

Takes an optional `omit` or `only` parameter, to filter out keys you don't care about. (Note: Omit is exclusive.)

``` js
// everything
processor.writeToFile(({
    output: '/path/to/destination.json',
}))


// everything but...
processor.writeToFile(({
    output: '/path/to/destination.json',
    omit: ['not', 'these', 'keys']
}))

// nothing except...
processor.writeToFile(({
    output: '/path/to/destination.json',
    only: ['just', 'these', 'keys']
}))
```


### processor.inspect
Inspects a key during processing. Use multiple inspections to see values change between stages.

``` js
processor.inspect("path.to.key") // logs value at key
```